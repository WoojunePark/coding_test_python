# 그리디
## 항상 생각할 것
* 이걸 그리디로 해도 되나?
    * 의심 또 의심
* 반례    
    * 극단적 예시
    * 간단한 예시
* 간단한 증명
    * '이 문제 상황은 ~하기 때문에 그리디로 풀어도 된다'

## 최적해의 성질 생각해보기    
+ (최적해)^c = 골라지지 않은 다른 해 : 사이에 끼워질 수 없음

## 여러 접근 방법 생각해보기
### cheap ideas
* 가장 짧은 회의
* 가장 시작이 빠른 회의
* 가장 겹치는 회의가 적은 회의 : 기회비용이 제일 적은

### calculated init : 1, n->n+1 (점화)
* 첫번째 회의 (a_1)
    * 어떤 회의를 골랐을 때 끝나는 시간이 더 빠른 회의가 있다면
        * 그걸 가장 빠른 회의로 해야
        * = 끝나는 시간이 가장 빠른 회의를 골라야 함
    * 그 회의와 겹치는 회의는 다 후보에서 지움
* 두번째 회의 및 그 다음 (a_n)
    * 마찬가지로 남은 회의중 
        * = 끝나는 시간이 가장 빠른 회의를 골라야 함
* Terminal condition (n < N)
    * 더 이상 회의가 남아있지 않음
* 구현
    * 끝나는 시간 순으로 정렬
        * 끝나는 시간이 제일 빠름
        * 시작 시간이 그 이전 회의 다음
* 시간 복잡도
    * 회의들을 끝나는 순으로 정렬 + 비교 (상수시간)
    * = O(NlogN)
* 예외 상황
    * 길이가 0인 회의들
        * 끝나는 시간이 같으면
            * 가장 뒤에 가도록

### random init : 점진적 개선 (진화)
* 임의의 해답
    * -> (하나씩 바꿔가며) 최적의 해답
* 최적해의 성질 생각해보기
    * 얘가 최적해가 아니라면 어떤 조건을 미충족해서 그런 거지?
    * = 뭘 만족하면 최적해지?
* 변수/비율 하나 고정해보기
* 구현 및 시간 복잡도 고려
    * 가장 나이브한 구현
    * 문제의 조건에 따라서 자료구조 활용 (시간복잡도 줄이기)
        * 가장 적은 갯수 (+ 방향)
            * 하나씩 더하기 (조건)
            * 그때 고려하지 않아도 되는 케이스들
        * 전부 다 고려 (- 방향)
            * 하나씩 빼기 (조건)
        * 자료구조
            *  Priority Queue